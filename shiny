2.2.1
All input functions have the same first argument: inputId. This is the identifier used to connect the front end with the back end: if your UI has an input with ID "name", the server function will access it with input$name.

The inputId has two constraints:
(i) It must be a simple string that contains only letters, numbers, and underscores (no space, dashes, periods, or other special characters allowed). Name it like you would name a variable in R.
(ii) It must be unique. If it's not unique, you'll have no way to refer to this control in your server function.

Most input functions has a second parameter called label. This is used to create a human-readable label for the control. Shiny doesn't place any restrictions on this string, but you'll need to carefully think about it to make sure that your app is usable by humans. The third parameter is typically value, which, where possible, lets you set the default value. The remaining parameters are unique to the control.

When creating an input, use arguments like this.
> silderInput("min", "Limit (minimum)", value = 50, min = 0, max = 100)
 
2.2.2 Free text
Collect small amounts of text with textInput(), passwords with passwordInput(),and paragraphs of text with textAreaInput(). Use validate() to ensure the text has certain properties.
> ui <- fluidPage(
    textInput("name","What's your name?"),
    passwordInput("password", "What's your password?"),
    textAreaInput("story", "Tell me about yourself", rows = 3)  
)

2.2.3 Numeric inputs
To collect numeric values, create a constrained text box with numericInput() or a slider with sliderInput(). If you supply a length-2 numeric vector for the default value of sliderInput(), you get a "range" value slider with two ends.
> ui <- fluidPage(
    numericInput("num","NUMBER ONE", value = 0, min = 0, max = 100),
    sliderInput("num2", "NUMBER TWO", value = 50, min = 0, max = 100),
    sliderInput("rng", "	Range", value = c(10,20), min = 0, max = 100)  
)

2.2.4 Dates

2.2.5 Limited choices
There are two different approaches to allow the user to choose from a respecified set of options: selectInput() and radioButtons().
> animals <- c("dog", "cat", "mouse", "bird", "other", "I hate animals")
> ui <- fluidPage(
     selectInput("state", "What's your favourite state?", state.name),
     radioButtons("animals", "What's your favorite animal?", animals)
)

Radio buttons have two nice features: they show all possible options, making them suitable for short lists, and via the choiceNames/choiceValues arguments, they can display options other than plain text. choiceNames determines what is shown to the user; choiceValues determines what is returned in your server function.
> ui <- fluidPage(
    radioButtons("rb", "Choose one:"),
       choiceNames = list(
          icon("angry"),
          icon("smile"),
          icon("sad-tear")
       ),
       choiceValues = list("angry", "happy", "sad")
     )
)

Dropdowns created with selectInput() take up the same amount of space, regardless of the number of options, making them more suitable for longer options. You can also set multiple = TRUE to allow the user to select multiple elements.
> ui <- fluidPage(
    selectInput(
       "state", "What's your favorite state?", state.name,
       Multiple = TRUE
    )
)

There's no way to select multiple values with radio buttons, but there's an alternative that's conceptually similar: checkboxGroupInput().
> ui <- fluidPage(
    checkboxGroupInput("animal", "What animals do you like?", animals)
)

2.2.6 File uploads
Allow the user to upload a file with fileInput():
> ui <- fluidPage(
    fileInput("upload", NULL)
)

2.2.7 Action buttons
Let the user perform an action with actionButton() or actionLink():
> ui <- fluidPage(
    actionButton("click", "Click me!"),
    actionButton("drink", "Drink me!", icon = icon("cocktail"))
)
Actions links and buttons are most naturally paired with observeEvent() or eventReactive() in your server function.
You can customize the appearance using the class argument by using one of "bin-primary", "bin-success", "bin-info", "btn-warning", or "ban-danger". You can also change the size with "btn-lg", "btn-sm", "ban-xs". Finally, you can make buttons span the entire width of the element they are embedded within using "bin-block".
> ui <- fluidPage(
    fluidRow(
       actionButton("click", "click me!", class = "btn-danger"),
       actionButton("click", "drink me!", class = "btn-lg ban-success"),
),
    fluidRow(
       actionButton("eat", "eat me!", class = "btn-block")
    )
)
The class argument works by setting the class attribute of the underlying HTML, which affects how the element is styled.

2.3 Outputs
Outputs in the UI create placeholders that are later filled by the server function. Like inputs, outputs take a unique ID as their first argument: if your UI specification creates as output with ID "plot", you'll access it in the server function with output$plot.

Each output function on the front end is coupled with a render function in the back end. There are three main types of output, corresponding to the three things you usually include in a report: text, tables, and plots.

2.3.1 Text
Output regular text with textOutput() and fixed code and console output with verbatimTextOutput()

> ui <- fluidPage(
    textOutput("text"),
    verbatimTextOutput("code")
)
> server <- function(input, output, session){
    output$text <- renderText({
       "Hello friend!"
    })
    output$code <- renderPrint({
       summary(1:10)
    })
}
Note that the {} are only required in render functions if need to run multiple lines of code. Should do as little computation in your render functions as possible, which means you can often omit them. Here's what the server function above would look like I written more compactly:
> server <- function(input, output, session){
   output$text <- renderText("hello friend!")
   output$code <- renderPrint(summary(1:10))
}
Note that there two render functions which behave slightly differently:
(i) renderText() combines the result into a single string, and is usually paired with textOutput()
(ii) renderPrint() prints the result, as if you were in an R console, and is usually paired with verbatimTextOutput()
See the difference as the app below:
> ui <- fluidPage(
    textOutput("text"),
    verbatimTextOutput("print")
)
> server <- function(input, output, session){
    output$text <- renderText("hello!")
    output$print <- renderPrint("hello!")
}
This is equivalent to the difference between cat() and print() in base R.

2.3.2 Tables
There are two options for displaying data frames in tables:
(i) tableOutput() and renderTable() render a static table of data, showing all the data at once
(ii) dataTableOutput() and renderDataTable() render a dynamic table, showing a fixed number of rows along with controls to change which rows are visible
tableOutput() is most useful for small, fixed summaries (e.g. model coefficients); dataTableOutput() is most appropriate if you want to expose a complete data frame to the user.  
> ui <- fluidPage(
    tableOutput("static"),
    dataTableOutput("dynamic")
)
> server <- function(input, output, session) {
     output$static <- renderTable(head(mtcars))
     output$dynamic <- renderDataTable(mtcars, options = list(pageLength = 5))
}

2.3.3 Plots
You can display any type of R graphic(base, ggplot2, o otherwise) with plotOutput() and renderPlot()
